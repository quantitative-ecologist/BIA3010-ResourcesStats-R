---
title: Séries d'ateliers R - UQAM - BIA3010
subtitle: Atelier 3 - Comparaisons de moyennes, ANOVA, et régression simple
author:
  - name: | 
        Maxime Fraser Franco : 
    affiliation: Département des Sciences Biologiques & Centre de la Science de la Biodiversité du Québec, Université du Québec à Montréal
    email: fraser_franco.maxime@courrier.uqam.ca
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_float: yes
    highlight: zenburn
    theme: flatly
    df_print: paged
    #code_folding: hide
#bibliography: refs-MLMM.bib
#nocite: |
#  @McElreath2020
#  @Burkner2017
#  @Burkner2018
#  @FraserFranco.etal2022
#  @Piironen.Vehtari2017
#  @aczelDiscussionPointsBayesian2020
#  @kruschkeBayesianAnalysisReporting2021
#  @Vehtari.etal2017
---

<br>

# Sommaire

Dans cet atelier, nous allons voir comment utiliser R pour effectuer trois types d'analyses classiques en biologie, mais aussi même dans plusieurs sciences en général. Ces trois analyses sont:

- La comparaison de moyennes
- L'analyse de variance (ANOVA)
- La régression linéaire simple

Ces trois analyses sont utilisées pour différents cas de figure et dépendent du "design" expérimental que vous avez fait. Nous allons voir comment reconnaître ces cas de figure pour rapidement évaluer le type d'analyse nécessaire pour répondre à nos questions.

**À noter**: le présent document est en format .html et a été généré avec [R Markdown](https://rmarkdown.rstudio.com/). C'est simplement une façon de générer des documents beaux pour expliquer du code. Ainsi, vous pouvez copier-coller le code de chaque cellule dans une session R sur votre ordinateur personnel et produire l'ensemble des analyses présentées dans le document.

<br>




# Préparer notre session

Pour initier notre session de programmation dans R, il nous faudra faire 2 étapes essentielles. La première sera de charger les librairies nécessaires pour effectuer nos analyses, puis ensuite d'importer nos données dans la session pour commencer à les manipuler et les modéliser.


## Charger les librairies

Voici les librairies que nous utiliserons:

- Package [`lme4`](https://cran.r-project.org/web/packages/lme4/index.html) pour des modèles linéaires (ANOVA, ANCOVA, modèles mixtes, etc.) "classiques"
- Package [`ggplot2`](https://ggplot2.tidyverse.org/) pour faire de magnifiques graphiques
- Package [`data.table`](https://rdatatable.gitlab.io/data.table/index.html) et le [`tidyverse`](https://www.tidyverse.org/) pour la manipulation de données

Chargons donc nos librairies. Si vous ne les avez pas installées, vous devez tout dabord le faire en faisant la commande `install.packages("librairie")`.
```{r}

# Définir le vecteur des librairies à charger
packages <- c("lme4", "ggplot2", "data.table")

# Charger toutes les librairies d'un coup
lapply(packages, library, character.only = TRUE)

```


## Importer les données

Dépendemment de comment vous utilisez R, vous devrez tout d'abord peut-être devoir "set" votre working directory avec `setwd("votre/chemin/dans/windows/ou/mac")`

Par contre, si vous travaillez à l'échelle du projet dans Rstudio comme nous avons vu à l'atelier 1, alors pas besoin de `setwd()`. Vous pourrez confirmer que vous êtes déjà dans le bon chemin (dossier) en faisant la commande `getwd()`.

Nous allons travailler avec trois bases de données différentes. La première consiste en des données de capture de micro-mammifères, et l'autre des données de fragments forestiers. La troisième table sont des données de taille de zooplancton échantillonnées dans 4 lacs.
```{r}
# Données de capture d'espèces dans différents fragments
donnees_capture <- read.table(
    file = "./data/donnees-captures.csv",
    header = TRUE, sep = ";", dec = "."
)

# Données de superficie de fragments forestiers selon le type de forêt
donnees_fragments <- read.table(
    file = "./data/donnees-fragments.csv",
    header = TRUE, sep = ";", dec = "."
)

# Données de tailles de zooplancton prises dans différents lacs
donnees_zoo <- read.table(
    file = "./data/donnees-zoo.csv",
    header = TRUE, sep = ";", dec = "."
)
```

<br>




# Visualiser nos données bruts

```{r}
str(donnees_capture)
head(donnees_capture)
```

```{r}
str(donnees_fragments)
head(donnees_fragments)
```

```{r}
str(donnees_zoo)
head(donnees_zoo)
```

<br>




# Préparer une table de données pour les analyses

Nous allons tout d'abord créer une table synthétique pour les données de captures et de types de fragments forestiers. Nous reviendrons plus tard aux données de taille de zooplancton qui sont déjà prêtes à être analysées.

Nous allons en premier lieu calculer le nombre de captures par fragment forestier en utilisant la fonction `aggregate()`. L'argument `FUN = length` réfère à la fonction qui est utilisée pour faire le calcul à travers les fragments.
```{r}
nbr_captures <- aggregate(
    donnees_capture$capture,
    list(donnees_capture$fragment),
    FUN = length
)

# On renomme les colones
names(nbr_captures) <- c("fragment", "nbr_capture")
```

On va ensuite créer un objet sous forme de `data.frame` où on conserve comme information seulement la liste des espèces trouvées par fragment forestier. Visualisons à quoi ressemble notre table.
```{r}
donnees_capture1 <- unique(donnees_capture)
head(donnees_capture1)
```

À partir de l'objet créé `donnees_capture1`, on recense le nombre d'espèces par fragment. À noter que notre unité d'échantillonage est le fragment qui sont des réplicas pour le type de fragment forestier, soit, coupe totale, coupe partielle, et la forêt mature. 
```{r}
nbr_especes <- aggregate(
    donnees_capture1$capture,
    by = list(donnees_capture1$fragment),
    FUN = length
)
names(nbr_especes)  <- c("fragment", "nbr_especes")
```

Finalement, la dernière étape consiste à combiner les données que nous avons créé pour avoir une table synthétique prête à être utilisée pour nos analyses.
```{r}
nbrs <- merge(nbr_captures, nbr_especes, by = "fragment")
data_final <- merge(donnees_fragments, nbrs, by = "fragment")
```

On peut visualiser la structure de cette table pour bien la comprendre.
```{r}
str(data_final)
head(data_final)
``` 

La table consiste en une liste de 80 fragments forestiers issus de forêts matures, forêts à coupe partielle, et forêt à coupe totale. Notez que nous avons la superficie de chaque fragment forestier échantillonné. Finalement, l'information cruciale consiste en le nombre de captures qui ont été effecutées à chaque fragment, ainsi que le nombre d'espèces qui a été observé à ces fragments. À la lumière de ces informations, quelles questions écologiques pourrions-nous nous poser et quel type d'analyse pourrions-nous faire pour répondre à nos questions?

<br>




# Comparer des moyennes

Nous allons revenir à notre table de zooplancton et l'utiliser pour comparer les moyennes. Rappelez-vous que dans cette table, nous avons échantillonné du zooplancton à travers 4 lacs et mesuré individuellement la taille des zooplanctons.

La première question qu'on peut se poser est de savoir quelle est la moyenne de notre échantillon pour l'ensemble des lacs?
```{r}
mean(donnees_zoo$taille)
```

Qu'en est-il de la taille de nos zooplanctons par lac? Voyons-voir :
```{r}
aggregate(
  taille ~ lac,
  data = donnees_zoo,
  FUN = mean
)
```

Rapidement, il semble que nos moyennes diffèrent. Par contre, pour confirmer que cela est le cas, il va falloir le tester "statistiquement". La méthode la + simple et connue est le test de Student.

## Comparaison de moyenne à une valeur théorique

Commençons par une comparaison de moyenne à une valeur théorique. Ici, on assume que la moyenne théorique est de 1000 um, et on compare la taille globale de tous nos lacs pour voir si elle est inférieure ou supérieure à la valeur moyenne théorique.

```{r}
t.test(donnees_zoo$taille, mu = 1000)

# En prenant seulement 1 lac parmi les 4
t.test(
    donnees_zoo[donnees_zoo$lac == "labrecque", ]$taille,
    mu = 1000
)
```

On voit que nos tailles d'effet sont très grandes et nos valeurs p sont très petites. On peut donc affirmer avec certitude que nos moyennes sont effectivements différentes à cette valeur. Dans notre cas, la moyenne est inférieure.


## Comparaison de moyenne entre 2 échantillons indépendants

Ici, on compare deux des lacs échantillonnés. On assume que les variances sont égales (même si ici, ce n'est pas le cas)
```{r}
t.test(
    donnees_zoo[donnees_zoo$lac == "labrecque",]$taille,
    donnees_zoo[donnees_zoo$lac == "cerne",]$taille,
    var.equal = TRUE, paired = FALSE
)
```

Pour être honnête, les tests de Student sont très vieux et il existe des méthodes beaucoup plus élégantes et robustes pour comparer des moyennes. Toutefois, il faut un début à tout et vous savez maintenant comment facilement et rapidement comparer des moyennes.

<br>




# L'analyse de variance