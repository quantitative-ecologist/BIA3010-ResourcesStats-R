---
title: UQAM - BIA3010 - Atelier 1
subtitle: Fonctions de base et manipulation de données avec R
author:
  - name: | 
        Maxime Fraser Franco : 
    affiliation: Département des Sciences Biologiques & Centre de la Science de la Biodiversité du Québec, Université du Québec à Montréal
    email: fraser_franco.maxime@courrier.uqam.ca
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    number_sections: yes
    toc: yes
    toc_float: yes
    highlight: zenburn
    theme: flatly
    df_print: paged
    #code_folding: hide
#bibliography: refs-MLMM.bib
#nocite: |
#  @McElreath2020
#  @Burkner2017
#  @Burkner2018
#  @FraserFranco.etal2022
#  @Piironen.Vehtari2017
#  @aczelDiscussionPointsBayesian2020
#  @kruschkeBayesianAnalysisReporting2021
#  @Vehtari.etal2017
---

Vous pouvez toujours trouver réponse à vos questions de R sur stackoverflow et stackexchange. Presque toutes les questions possibles sont posées!

<br>




# Gestion de projet/dossiers

Voici une liste d'éléments à retenir de nos discussions durant l'atelier en classe.


## Aspects fondamentaux

- Rappelez vous des différences entre le script, la console, et l'environnement
- Rappelez-vous de travailler à l'échelle du projet.  Ça évite des conflits de working directory quand on veut enregistrer et ouvrir des fichiers dans R
- Rappelez-vous que le working directory est l'endroit ou votre robot (console) travaille


## Manières d'éxécuter R

- via R directement
- via RStudio
- via VSCode
- via votre dossier (projet) en entrant rstudio ou r (permet d'établir l'espace courant directement sans utilsier `setwd()`). Cette méthode requiert de mettre le chemin de votre installation dans votre environnement Windows (`PATH`)


## Quelques points importants à retenir : 
- Ne JAMAIS enregistrer le workspace (une nouvelle session devrait être toujours "fresh")
- TOUJOURS enregistrer vos scripts! C'est fondamental.
- N'oubliez pas, pas d'accents ou d'espaces dans les noms de fichiers

<br>




# Comment les librairies (packages) fonctionnent ?


## Description et exemples de librairies populaires

Les librairies sont développées et déposés sur le [CRAN](https://cran.r-project.org/)  pour faire des choses qu'on veut.

Voici quelques exemples :

- Package [`vegan`](https://vegandevs.github.io/vegan/index.html) ou [`FactoMineR`](https://github.com/husson/FactoMineR) pour les analyses multivariées
- Package [`lme4`](https://cran.r-project.org/web/packages/lme4/index.html) pour des modèles linéaires (ANOVA, ANCOVA, modèles mixtes, etc.) "classiques"
- Package [`brms`](https://paul-buerkner.github.io/brms/) pour toutes sortes de modèles utilisant l'inférence bayésienne
- Package [`ggplot2`](https://ggplot2.tidyverse.org/) pour faire de magnifiques graphiques
- Package [`data.table`](https://rdatatable.gitlab.io/data.table/index.html) et le [`tidyverse`](https://www.tidyverse.org/) pour la manipulation de données


## Importer des librairies dans une session

Voici la commande qu'on utilise pour charger une librairie dans une session R. Cela va nous permetre ensuite d'utiliser l'ensemble des fonctions de cette librairies pour faire les opérations qu'on veut.
```{r}
library(data.table)
```

<br>




# Organisation des données


## Importer des données dans une session

### Exemple avec `data.table`

Voici une exemple de ce à quoi ressemble une fonction. Dans cet exemple, on prend une fonction issue de la librairie `data.table`. Comme mentionné plus haut, data.table est une librairie développée pour la manipulation de grandes bases de données. Dans cet exemple, nous voulons importer des données dans notre session. Ces données pourraient se trouver n'importe où (notre ordinateur, sur internet, ou sur un serveur). Ici,  nous allons importer le fichier `donnees1.csv` qui se trouve dans notre dossier.
```{r}
data <- fread(
    file = "./data/donnees1.csv"
)
```

Vérifions la structure des données. On fait ceci avec la fonction `str()`
```{r}
str(data)
```

on peut remarquer 2 choses :
- Les données de taille sont automatiquement reconnues comme étant numériques
- Les données de lac et de date sont automatiquement encodées comme caractère (`chr`) pour les lacs, et comme `IDate` pour les dates.

Ceci constitue un avantage d'utiliser `data.table` puisque le formattage se fait automatiquement et correctement lorsqu'on importe les données.

### Exemple avec les librairies de base

On peut aussi très bien utiliser des fonctions intégrées dans R. L'avantage est que notre session ne dépend d'aucune librairie et cela peut augmenter la stabilité du code à travers le temps.
```{r}
data <- read.table(
    file = "./data/donnees1.csv",
    header = TRUE, sep = ";", dec = "."
)

str(data)
```

Si on vérifie la structure de nos données, on voit que c'est différent de lorsqu'on a utilisé `data.table` et `fread()`. On voit maintenant que les colones lac et taille sont maintenant de type `chr`, ce qui n'est pas ce qu'on veut pour une colone de temps. Toutefois, il n'est pas trop grave que cela se produise car nous pouvons changer le "type" de nos colones sans problèmes.

À titre d'exemple, voici une autre fonction d'importation de données dans R. Comme vous pouvez le constater, les options sont diverses.
```{r}
data <- read.csv("./data/donnees1.csv", sep = ";")
str(data)
```

Maintenant que vous savez comment importer des données dans une session R, n'oubliez pas ces bonnes pratiques:
- NE JAMAIS MODIFIER LES DONNÉES BRUT (fichier .csv Excel, soit, vos données finales)
- Faites-vous des données nettoyées que vous utilisez pour vos analyses.
- Nettoyez les dans Excel et enregistrez-les sous de nouveaux noms si vous n'êtes pas à l'aise de le faire directement dans R.
- Vous devriez tous avoir exactement les mêmes données dans votre équipe de travail!

<br>




# Commandes de base


## Manipulation de données

### Aller chercher une colone dans les données

```{r}
data$taille # retourne un vecteur
data[, 1] # retourne un vecteur
```


### Créer une nouvelle colone

Ici, on fait le log de la taille et on créé une nouvelle colone.
```{r}
data$log_taille <- log(data$taille)
```

### Changer le type d'une colone

Ici, on change le type de la colone `lac` qui passe de type `chr` à type `factor`.
```{r}
data$lac <- as.factor(data$lac)
```

### Changer le nom d'une colone

On peut renommer une colone en spécifiant le nom de l'ancienne dans la table. Une deuxième façon est d'utiliser l'indexation pour aller chercher la colone dans sa position dans la table, ici, étant 2 car `lac` est la 2e colone de notre table `data`. Ici, on va changer le nom de la colone `lac` à `lacs`
```{r}
# Renommer une colone en spécifiant le nom
colnames(data)[colnames(data) == "lac"] <- "lacs"

# Renommer une colone en spécifiant sa position
colnames(data)[2] <- "lacs"
```


## Chercher des informations sur les données

Opérations relatives à la session
```{r}
ls() # Les objets qu'on a créé qui se trouvent dans l'environnement
sessionInfo() # informations sur notre session actuelle
```

Opérations sur un objet. Ici on fait des opérations sur l'ensemble de notre objet `data`.
```{r}
str(data) # structure des données
head(data, 6) # 6 premières lignes (essayez de changer la valeur)
summary(data) # sommaire de nos données
dim(data) # dimensions des données (observations colones)
nrow(data) # observations
ncol(data) # colones
```

Opérations sur des éléments d'un objet. Ici, on fait des opérations sur la colonne `taille` de notre objet `data`.
```{r}
# Opérations sur des colones
range(data$taille) # étendue des valeurs de la colone taille
mean(data$taille) # moyenne de la colone taille
sd(data$taille) # écart-type de la colone taille
```


## Quelques exemples d'indexation

L'indexation permet d'aller chercher des éléments d'un objet directement sans avoir besoin d'écrire leur nom. C'est donc + efficace et + rapide. Par contre attention, si vous ajoutez ou supprimez des colones ou que vous changez la structure de votre table, assurez-vous de changer le numéro de référence lorsque vous indexez.
```{r}
# Indexer colone
data[, 1]
data[, 2]

# Indexer ligne
data[1, ]

# Indexer ligne et colone
data[8, 3]
```

<br>




# Inspection des données

Identifier des NA
```{r}
sum(is.na(data$taille))
```

Identification d'erreurs d'entrée

Identifier si les niveaux d'un facteur ou cellules dans une colone de type caractère sont tous pareilles. Ceci peut aider à identifier si vous avez fait des erreurs dans les noms (ex. d'espèces) rentrées dans la colone. On va introduire une erreur pour tester
```{r}
data[1,2] <- "salut"
levels(as.factor(data$lacs))
# On voit maintenant qu'on a 5 lacs incluant salut.
```

Filtrer par groupe
```{r}
data[data$lacs == "labrecque", ]
data[data$lacs == "cerne", ]
```

Vous pouvez enregistrer une portion des données dans un objet. Ici, on garde seulement les données pour le lac Cerne
```{r}
data_cerne <- data[data$lacs == "cerne", ]
```

Compter le nombre de caractères différents qu'on a. Ici ça va retourner 4 car nous avons 4 lacs différents
```{r}
length(unique(data$lacs))
```

Vérifier la distribution des données avec des histogrammes
```{r}
hist(data$taille, breaks = 20)
hist(data[data$lacs == "labrecque", ]$taille)
hist(data[data$lacs == "ledoux", ]$taille)
```

```{r}
# Vérifier la taille par lac
boxplot(data$taille ~ data$lacs)
with(data, boxplot(taille ~ lacs))
```